Jaime Reynoso and Silvia Carbajal
CS214 - PA6
System's Programming

				PA6 design

Data Struct

	Our data struct was called a Header, it was an enum with a struct, s, and a Long int called Align. We had the struct Align variable in there because we need to align the data structure's in memory, so having a standard was important for the block. The struct s contained a pointer to another header, a size variable and a usedFlag variable. In our dynamic.c file we had a value called usedFlagValue, this indicated whether or not the block was free or whether it was in use. 

Design

	First, we defined a couple of macros, so that whenever myMalloc(), myFree(), myRealloc() or myCalloc() were called, they sent in their line numbers as well. This way we could determine where the error happened in the original code. We maintained 2 base Headers and 2 Header pointers. The largefreep pointer would be the pointer for large data types or anything that's over 100 bytes and the smallfreep would point to small data types, anything smaller than 100 byte. In order to reduce fragmentation, we made sure the small blocks would be allocated from the left side of the 5000 char array pointer and that the large blocks would be allocated from the right side of the 500 char pointers, this way when we free a small block and try to allocate the small block, we would allocate it from the pointers that are likely to have a similar size. We maintained a double Header pointer inside the free, malloc, myMorecore and getMem functions in order to have the function decide which pointer pointed to the correct free linked list. We also made sure that the base got initiated before we started looking for a suitable location in memory. 
	In myMalloc() whenever we found a free pointer that had more than enough space to allocate the data struct, we made the block smaller and fixed the size. We also made sure to change the usedFlag variable, in order to let the system know that if someone inputs a variable with a different usedFlag value then it was not returned by malloc(). If we don't have any more space, then the system calls myMorecore() function. The myMorecore() function calls the getMem function, which returns either a pointer to a set of address space in my char [5000] or -1 if there wasn't enough space for the object.
	myFree() checks whether or not the address of the variable is lower than the first address in the virtual memory or larger than the last address in memory, this makes sure that the address is at least a possible address for a malloc'ed function. It then checks whether or not the usedFlag value is correct for a used bloc, if not then the address is free. After checking the size, the free() function checks the size of the variable, if it's larger than 100 bytes, it chooses the appropriate pointer to find the start of free linked list. Instead of maintaining 2 headers per same block size, we check to see whether the address to the right or to the left matches the size you need and then we make it one large block. 
	We created the myRealloc() function as well. It was really simple, we just needed to retrieve the pointer to the header. If the pointer is null, then we just call malloc function with the size that we need. If someone is looking for a smaller block, we return the same block because Realloc only changes the pointer if the block we need is larger than the one we have. After we memcpy the pointer, we free the old pointer and return the new one.
	We created the myCalloc() function as well. It was the easiest function because we just needed to myMalloc() a size equal to the size of the type multiplied by the number of types we needed, then memset the whole address to 0 and return the pointer;
